import type { Race, StatsResult, BacktestConfig } from "./types";
import { getPayoutBucket, EQUAL_SLOT_PROBABILITY } from "./utils";

/**
 * The core decision engine.
 *
 * It combines historical statistical data with HMM-based sequence predictions
 * to determine the best bets for a given race.
 *
 * The algorithm:
 * 1. For each of the 6 slots:
 *    a. Map the current race's payout to a bucket (Favored, Neutral, Longshot).
 *    b. Retrieve historical win rates for that slot + bucket.
 *    c. Blend in Venue and Round-specific performance if available.
 *    d. Calculate Historical Expected Value (EV).
 *    e. Estimate HMM-based EV using the transition probabilities for the next state.
 *    f. Combine both EV scores using configurable weights.
 * 2. Select slots that exceed the minimum score and relative edge thresholds.
 *
 * @param currentRace - The metadata and payouts for the upcoming race.
 * @param stats - Aggregated historical win rate statistics.
 * @param aggregatedProbs - Probabilities generated by the HMM ensemble for each possible win outcome.
 * @param config - Betting and scoring configuration parameters.
 */
export function predictRace(currentRace: Race, stats: StatsResult, aggregatedProbs: Float64Array, config: BacktestConfig): { bets: number[]; score: number } {
    // aggregatedProbs is an array of 18 observation probabilities (6 slots * 3 buckets)
    // We condense these into 6 probabilities—one per slot—by summing across the 3 buckets for each slot.
    const hmmSlotProbs = new Float64Array(6);
    for (let i = 0; i < 18; i++) {
        const slotIndex = Math.floor(i / 3);
        const prob = aggregatedProbs[i];
        if (prob !== undefined) {
            const current = hmmSlotProbs[slotIndex] ?? 0;
            hmmSlotProbs[slotIndex] = current + prob;
        }
    }

    const candidates = [];
    for (let s = 0; s < 6; s++) {
        const slot = s + 1;
        const payout = currentRace.payouts[s] ?? 0;
        const bucket = getPayoutBucket(payout, slot);
        const hmmProb = hmmSlotProbs[s] ?? 0;

        // Retrieve multidimensional statistics
        const bStat = stats.bucketMap[slot]?.[bucket];
        const vStat = currentRace.venue ? stats.venueMap[currentRace.venue]?.[slot] : undefined;
        const rStat = stats.roundMap[currentRace.raceNumber]?.[slot];

        // Start with the base win rate for this slot in this payout bucket
        // Fallback to the empirical prior from config for this slot if no bucket-specific data exists
        let winRate = bStat?.winRate ?? config.empiricalWinRates?.[slot] ?? EQUAL_SLOT_PROBABILITY;

        // Blend in Venue context (20% weight) if we have enough samples
        if (vStat && vStat.occurrences >= 2) {
            winRate = winRate * 0.8 + vStat.winRate * 0.2;
        }
        // Blend in Round context (15% weight) if we have enough samples
        if (rStat && rStat.occurrences >= 2) {
            winRate = winRate * 0.85 + rStat.winRate * 0.15;
        }

        /**
         * Expected Value (EV) optimization:
         * Formula: (WinProb * NetProfit) - (LossProb * BetAmount)
         * Since BetAmount = 1 unit: (winRate * (payout - 1)) - (1 - winRate)
         * Simplified: winRate * payout - 1
         */
        const histEV = winRate * payout - 1;
        const hmmEV = hmmProb * payout - 1;

        // Apply momentum bonus if this slot won the previous race
        let momentumBonus = 0.0;
        if (slot === stats.lastWinningSlot) {
            // Use a dynamic bonus based on historical momentum data
            // Calculate momentum bonus from historical data instead of hardcoding
            if (stats.momentumBonus !== undefined) {
                momentumBonus = stats.momentumBonus;
            } else {
                // Fallback to hardcoded value if no momentum data available
                momentumBonus = 0.29; // Using our observed momentum factor (1.29x - 1.0) scaled to 0-1 range
            }
        }

        // Apply Zig-Zag bonus (preference for small step sizes based on empirical analysis)
        // Step 0 (Same slot): High probability
        // Step 1 (Adjacent slot): Highest probability overall
        let zigZagBonus = 0.0;
        if (stats.lastWinningSlot !== null) {
            const dist = Math.abs(slot - stats.lastWinningSlot);
            if (dist === 0) {
                zigZagBonus = 1.0;
            } else if (dist === 1) {
                zigZagBonus = 0.7; // Slightly less than 1.0 to weight "same" higher when combined with momentum, though raw freq is higher
            }
        }

        // Combine the historical statistical EV with the HMM sequence-based EV and momentum
        const score = histEV * config.scoreWeights.historical + 
                     hmmEV * config.scoreWeights.hmm + 
                     momentumBonus * config.scoreWeights.momentum +
                     zigZagBonus * config.scoreWeights.zigZag;

        candidates.push({ slot, score });
    }

    // Sort by combined EV score descending
    candidates.sort((a, b) => b.score - a.score);

    // Calculate the average score for the race to measure relative strength (the "Edge")
    const avgScore = candidates.reduce((acc, c) => acc + c.score, 0) / candidates.length;

    // Filter for bets that meet absolute ROI requirements and provide a significant advantage over other slots
    let bets = candidates
        .filter((c) => {
            const isAbovThreshold = c.score > config.minScoreThreshold;
            const hasRelativeEdge = c.score - avgScore > (config.relativeThreshold ?? 0);
            return isAbovThreshold && hasRelativeEdge;
        })
        .slice(0, config.betLimit)
        .map((c) => c.slot);

    return { bets, score: candidates[0]?.score ?? 0 };
}
